# üèóÔ∏è Arquitectura Hexagonal (Ports & Adapters)

## üìã Descripci√≥n General

Este proyecto implementa la **Arquitectura Hexagonal** (tambi√©n conocida como Ports & Adapters) en ambos microservicios. Esta arquitectura promueve la separaci√≥n de responsabilidades, la independencia de frameworks y la testabilidad del c√≥digo.

## üéØ Principios de la Arquitectura Hexagonal

### Objetivos Principales
- **Independencia de Frameworks**: El dominio no depende de tecnolog√≠as externas
- **Testabilidad**: F√°cil testing de cada capa de forma aislada
- **Flexibilidad**: Cambio de tecnolog√≠as sin afectar la l√≥gica de negocio
- **Separaci√≥n de Responsabilidades**: Cada capa tiene una responsabilidad espec√≠fica

## üèõÔ∏è Estructura de Capas

### Diagrama de Arquitectura Hexagonal

```mermaid
graph TB
    subgraph "External World"
        Client[Cliente HTTP]
        DB[(Base de Datos)]
    end
    
    subgraph "Adapters (Outer Layer)"
        Controller[Controllers]
        Repository[Repositories]
    end
    
    subgraph "Ports (Interfaces)"
        ServicePort[Service Ports]
        RepositoryPort[Repository Ports]
    end
    
    subgraph "Application (Inner Layer)"
        Service[Application Services]
        UseCases[Use Cases]
    end
    
    subgraph "Domain (Core)"
        Domain[Domain Models]
        BusinessRules[Business Rules]
    end
    
    Client --> Controller
    Controller --> ServicePort
    ServicePort --> Service
    Service --> Domain
    Service --> RepositoryPort
    RepositoryPort --> Repository
    Repository --> DB
    
    style Domain fill:#e1f5fe
    style Service fill:#f3e5f5
    style Controller fill:#fff3e0
    style Repository fill:#fff3e0
```

## üìÅ Estructura de Directorios

### Product Service
```
product-service/src/main/java/dev/scastillo/product/
‚îú‚îÄ‚îÄ adapter/                    # üéØ Adapters (Outer Layer)
‚îÇ   ‚îî‚îÄ‚îÄ web/                   # Web Adapters
‚îÇ       ‚îú‚îÄ‚îÄ controller/        # REST Controllers
‚îÇ       ‚îú‚îÄ‚îÄ dto/              # Data Transfer Objects
‚îÇ       ‚îî‚îÄ‚îÄ mapper/           # Object Mappers
‚îú‚îÄ‚îÄ application/               # üéØ Application (Inner Layer)
‚îÇ   ‚îî‚îÄ‚îÄ service/              # Application Services
‚îú‚îÄ‚îÄ domain/                   # üéØ Domain (Core)
‚îÇ   ‚îú‚îÄ‚îÄ model/                # Domain Entities
‚îÇ   ‚îú‚îÄ‚îÄ repository/           # Repository Ports (Interfaces)
‚îÇ   ‚îî‚îÄ‚îÄ service/              # Domain Services
‚îú‚îÄ‚îÄ infraestructure/          # üéØ Infrastructure Adapters
‚îÇ   ‚îî‚îÄ‚îÄ repository/           # Repository Implementations
‚îú‚îÄ‚îÄ config/                   # Configuration
‚îî‚îÄ‚îÄ shared/                   # Shared Components
```

### Inventory Service
```
inventory-service/src/main/java/dev/scastillo/inventory/
‚îú‚îÄ‚îÄ adapter/                   # üéØ Adapters (Outer Layer)
‚îÇ   ‚îî‚îÄ‚îÄ web/                  # Web Adapters
‚îÇ       ‚îú‚îÄ‚îÄ controller/       # REST Controllers
‚îÇ       ‚îú‚îÄ‚îÄ dto/             # Data Transfer Objects
‚îÇ       ‚îî‚îÄ‚îÄ mapper/          # Object Mappers
‚îú‚îÄ‚îÄ application/              # üéØ Application (Inner Layer)
‚îÇ   ‚îî‚îÄ‚îÄ service/             # Application Services
‚îú‚îÄ‚îÄ domain/                  # üéØ Domain (Core)
‚îÇ   ‚îú‚îÄ‚îÄ model/               # Domain Entities
‚îÇ   ‚îú‚îÄ‚îÄ repository/          # Repository Ports (Interfaces)
‚îÇ   ‚îî‚îÄ‚îÄ service/             # Domain Services
‚îú‚îÄ‚îÄ infraestructure/         # üéØ Infrastructure Adapters
‚îÇ   ‚îú‚îÄ‚îÄ repository/          # Repository Implementations
‚îÇ   ‚îî‚îÄ‚îÄ rest/               # External Service Clients
‚îú‚îÄ‚îÄ config/                  # Configuration
‚îî‚îÄ‚îÄ shared/                  # Shared Components
```

## üîÑ Flujo de Datos

### Diagrama de Flujo

```mermaid
sequenceDiagram
    participant Client as Cliente
    participant Controller as Controller
    participant Service as Application Service
    participant Domain as Domain Model
    participant Repository as Repository
    participant DB as Base de Datos

    Client->>Controller: HTTP Request
    Controller->>Controller: Validar DTO
    Controller->>Service: Llamar Use Case
    Service->>Domain: Aplicar Reglas de Negocio
    Service->>Repository: Persistir/Consultar
    Repository->>DB: Operaci√≥n BD
    DB-->>Repository: Resultado
    Repository-->>Service: Domain Object
    Service-->>Controller: Response DTO
    Controller-->>Client: HTTP Response
```

## üéØ Capas y Responsabilidades

### 1. üèõÔ∏è Domain Layer (Core)
**Responsabilidad**: L√≥gica de negocio pura, sin dependencias externas

#### Componentes:
- **Domain Models**: Entidades del negocio
- **Repository Ports**: Interfaces para acceso a datos
- **Domain Services**: L√≥gica de negocio compleja

#### Ejemplo:
```java
// Domain Model
@Entity
public class Product {
    private Integer id;
    private String name;
    private BigDecimal price;
    // L√≥gica de negocio pura
}

// Repository Port
public interface ProductRepository {
    Product save(Product product);
    Optional<Product> findById(Integer id);
}
```

### 2. üéØ Application Layer (Inner)
**Responsabilidad**: Orquestaci√≥n de casos de uso

#### Componentes:
- **Application Services**: Implementaci√≥n de casos de uso
- **Use Cases**: L√≥gica de aplicaci√≥n

#### Ejemplo:
```java
@Service
public class ProductServiceImpl implements ProductService {
    private final ProductRepository productRepository;
    
    public ProductResponse createProduct(CreateProductRequest request) {
        // Orquestaci√≥n del caso de uso
        Product product = new Product(request.getName(), request.getPrice());
        Product savedProduct = productRepository.save(product);
        return ProductMapper.toResponse(savedProduct);
    }
}
```

### 3. üéØ Adapter Layer (Outer)
**Responsabilidad**: Adaptaci√≥n a tecnolog√≠as externas

#### Componentes:
- **Controllers**: Adaptadores HTTP
- **DTOs**: Objetos de transferencia de datos
- **Mappers**: Conversi√≥n entre capas

#### Ejemplo:
```java
@RestController
public class ProductController {
    private final ProductService productService;
    
    @PostMapping("/products")
    public ResponseEntity<ProductResponseDto> createProduct(@RequestBody ProductCreateRequestDto request) {
        ProductResponse response = productService.createProduct(request);
        return ResponseEntity.ok(ProductMapper.toDto(response));
    }
}
```

### 4. üéØ Infrastructure Layer (Outer)
**Responsabilidad**: Implementaci√≥n de puertos

#### Componentes:
- **Repository Implementations**: Implementaci√≥n de repositorios
- **External Service Clients**: Clientes de servicios externos

#### Ejemplo:
```java
@Repository
public class JpaProductRepository implements ProductRepository {
    private final SpringDataProductRepository repository;
    
    @Override
    public Product save(Product product) {
        ProductEntity entity = ProductMapper.toEntity(product);
        ProductEntity savedEntity = repository.save(entity);
        return ProductMapper.toDomain(savedEntity);
    }
}
```

## üîÑ Inversi√≥n de Dependencias

### Diagrama de Dependencias

```mermaid
graph TD
    subgraph "High Level"
        A[Domain Models]
        B[Repository Ports]
        C[Application Services]
    end
    
    subgraph "Low Level"
        D[Controllers]
        E[Repository Implementations]
        F[External Services]
    end
    
    D --> C
    E --> B
    F --> B
    C --> A
    C --> B
    
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style C fill:#f3e5f5
    style D fill:#fff3e0
    style E fill:#fff3e0
    style F fill:#fff3e0
```

## ‚úÖ Ventajas de la Arquitectura Hexagonal

### 1. üß™ Testabilidad
- **Testing Aislado**: Cada capa se puede testear independientemente
- **Mocks F√°ciles**: Interfaces permiten mocking simple
- **Testing de Dominio**: L√≥gica de negocio sin dependencias

### 2. üîÑ Flexibilidad
- **Cambio de Frameworks**: Sin afectar l√≥gica de negocio
- **Cambio de Base de Datos**: Implementaci√≥n de repositorios
- **Cambio de APIs**: Nuevos adaptadores sin tocar core

### 3. üèóÔ∏è Mantenibilidad
- **Separaci√≥n Clara**: Responsabilidades bien definidas
- **C√≥digo Limpio**: Principios SOLID aplicados
- **Escalabilidad**: F√°cil agregar nuevas funcionalidades

### 4. üéØ Independencia
- **Framework Agnostic**: Dominio no depende de Spring
- **Technology Agnostic**: F√°cil cambio de tecnolog√≠as
- **Business Focus**: Enfoque en l√≥gica de negocio

## üîß Implementaci√≥n en el Proyecto

### Product Service
```java
// Domain Layer
public class Product { /* Domain Model */ }
public interface ProductRepository { /* Port */ }

// Application Layer
public class ProductServiceImpl implements ProductService { /* Use Case */ }

// Adapter Layer
public class ProductController { /* HTTP Adapter */ }

// Infrastructure Layer
public class JpaProductRepository implements ProductRepository { /* Implementation */ }
```

### Inventory Service
```java
// Domain Layer
public class ProductStock { /* Domain Model */ }
public interface ProductStockRepository { /* Port */ }

// Application Layer
public class ProductStockServiceImpl implements ProductStockService { /* Use Case */ }

// Adapter Layer
public class InventoryController { /* HTTP Adapter */ }

// Infrastructure Layer
public class JpaProductStockRepository implements ProductStockRepository { /* Implementation */ }
```

## üß™ Testing Strategy

### Testing por Capas

```mermaid
graph LR
    subgraph "Testing Strategy"
        A[Unit Tests<br/>Domain]
        B[Integration Tests<br/>Application]
        C[End-to-End Tests<br/>Adapters]
    end
    
    A --> B
    B --> C
    
    style A fill:#e8f5e8
    style B fill:#fff3e0
    style C fill:#fce4ec
```

### Ejemplo de Testing
```java
// Domain Testing
@Test
void shouldCalculateTotalPrice() {
    Product product = new Product("Laptop", BigDecimal.valueOf(1000));
    assertEquals(BigDecimal.valueOf(1000), product.getPrice());
}

// Application Testing
@Test
void shouldCreateProduct() {
    ProductService service = new ProductServiceImpl(mockRepository);
    ProductResponse response = service.createProduct(request);
    assertNotNull(response);
}

// Adapter Testing
@Test
void shouldReturnProductWhenValidRequest() {
    mockMvc.perform(post("/api/v1/products")
        .contentType(MediaType.APPLICATION_JSON)
        .content(jsonRequest))
        .andExpect(status().isOk());
}
```

## üöÄ Beneficios en Microservicios

### 1. **Independencia de Servicios**
- Cada microservicio tiene su propio dominio
- Interfaces bien definidas entre servicios
- F√°cil evoluci√≥n independiente

### 2. **Escalabilidad**
- Capas se pueden escalar independientemente
- F√°cil agregar nuevos adaptadores
- Testing de integraci√≥n simplificado

### 3. **Mantenimiento**
- Cambios localizados por capas
- F√°cil debugging y troubleshooting
- C√≥digo m√°s legible y organizado

## üìä M√©tricas de Calidad

### Cobertura por Capas
- **Domain Layer**: > 90%
- **Application Layer**: > 85%
- **Adapter Layer**: > 80%
- **Infrastructure Layer**: > 75%

### Principios Aplicados
- ‚úÖ **Single Responsibility Principle**
- ‚úÖ **Open/Closed Principle**
- ‚úÖ **Dependency Inversion Principle**
- ‚úÖ **Interface Segregation Principle**

## üéØ Conclusiones

La arquitectura hexagonal implementada en este proyecto proporciona:

1. **Flexibilidad**: F√°cil cambio de tecnolog√≠as
2. **Testabilidad**: Testing aislado por capas
3. **Mantenibilidad**: C√≥digo organizado y limpio
4. **Escalabilidad**: F√°cil agregar nuevas funcionalidades
5. **Independencia**: Dominio libre de frameworks

Esta arquitectura es especialmente beneficiosa en microservicios, donde cada servicio puede evolucionar independientemente manteniendo la coherencia del sistema. 